#!/bin/bash
# =============================================
# FPGA TESTING FUNCTIONS
# =============================================

# Variables globales
export FPGA_IP="192.168.1.128"
export FPGA_PORT="1234"
export NET_INTERFACE="enp4s0"
FPGA_PROJECT_DIR="/root/NetFPGA-SUME/firmware/NetFPGA_SUME/fpga/fpga"

# --------------------------------------------------
# FUNCIÓN: fpga_init
# Envía mensaje para que la FPGA comience el envio de datos
# --------------------------------------------------
function fpga_init {
    local message="${1:-....INIT}"
    echo "Enviando: $message"
    echo -n "$message" | nc -u -w 1 $FPGA_IP $FPGA_PORT
    echo "Mensaje de inicio enviado"
}

# --------------------------------------------------
# FUNCIÓN: fpga_fini 
# Envía mensaje para que la FPGA detenga el envio de datos
# --------------------------------------------------
function fpga_fini {
    local message="${1:-....FINI}"
    echo "Enviando: $message"
    echo -n "$message" | nc -u -w 1 $FPGA_IP $FPGA_PORT
    echo "Mensaje de fin enviado"
}

# --------------------------------------------------
# FUNCIÓN: fpga_loopback 
# Envía mensaje para que la FPGA active o desactive el loopback
# --------------------------------------------------
function fpga_loopback {
    if [ $# -ne 1 ]; then
        echo "Uso: fpga_loopback <enable/disable>"
        echo "Ejemplo: fpga_loopback enable"
        echo "Ejemplo: fpga_loopback disable"
        return 1
    fi

    local action="$1"
    local message=""
    
    # Determinar el mensaje basado en la acción
    case "$action" in
        (enable|e|on|1)
            message="LOOPBK_E"
            ;;
        (disable|d|off|0)
            message="LOOPBK_D"
            ;;
        (*)
            echo "Error: Acción no válida '$action'"
            echo "Uso: fpga_loopback <enable/disable>"
            return 1
            ;;
    esac

    echo "Enviando comando de loopback: $message"
    echo -n "$message" | nc -u -w 1 $FPGA_IP $FPGA_PORT
    
    if [ $? -eq 0 ]; then
        echo "✅ Comando '$message' enviado exitosamente a $FPGA_IP:$FPGA_PORT"
    else
        echo "❌ Error al enviar comando a $FPGA_IP:$FPGA_PORT"
        return 1
    fi
}

# --------------------------------------------------
# FUNCIÓN: fpga_random 
# Envía mensaje para que la FPGA active o desactive el random mode
# --------------------------------------------------
function fpga_random {
    if [ $# -ne 1 ]; then
        echo "Uso: fpga_random <enable/disable>"
        echo "Ejemplo: fpga_random enable"
        echo "Ejemplo: fpga_random disable"
        return 1
    fi

    local action="$1"
    local message=""
    
    # Determinar el mensaje basado en la acción
    case "$action" in
        (enable|e|on|1)
            message="RANDOM_E"
            ;;
        (disable|d|off|0)
            message="RANDOM_D"
            ;;
        (*)
            echo "Error: Acción no válida '$action'"
            echo "Uso: fpga_random <enable/disable>"
            return 1
            ;;
    esac

    echo "Enviando comando de loopback: $message"
    echo -n "$message" | nc -u -w 1 $FPGA_IP $FPGA_PORT
    
    if [ $? -eq 0 ]; then
        echo "✅ Comando '$message' enviado exitosamente a $FPGA_IP:$FPGA_PORT"
    else
        echo "❌ Error al enviar comando a $FPGA_IP:$FPGA_PORT"
        return 1
    fi
}

# --------------------------------------------------
# FUNCIÓN: fpga_pkt_n
# Configura el número de paquetes por pulso
# Uso: fpga_pkt_n <número_de_paquetes|max>
# Ejemplo: fpga_pkt_n 256
# Ejemplo: fpga_pkt_n max
# --------------------------------------------------
function fpga_pkt_n {
    if [ $# -ne 1 ]; then
        echo "Uso: fpga_pkt_n <número_de_paquetes|max>"
        echo "Ejemplo: fpga_pkt_n 256"
        echo "Ejemplo: fpga_pkt_n max"
        return 1
    fi
    
    local packets=$1
    local max_uint32=4294967295
    
    # Si el parámetro es "max", usar el valor máximo
    if [ "$packets" = "max" ]; then
        packets=$max_uint32
        echo "Usando número máximo de paquetes: $packets"
    fi
    
    # Validar que sea un número positivo dentro de 32 bits
    if ! [[ "$packets" =~ ^[0-9]+$ ]] || [ "$packets" -lt 1 ] || [ "$packets" -gt "$max_uint32" ]; then
        echo "Error: El número debe estar entre 1 y $max_uint32, o usar 'max'"
        return 1
    fi
    
    # Convertir número a 4 bytes en BIG-ENDIAN
    local byte3=$(( (packets >> 24) & 0xFF ))  # MSB
    local byte2=$(( (packets >> 16) & 0xFF ))
    local byte1=$(( (packets >> 8)  & 0xFF ))
    local byte0=$(( (packets >> 0)  & 0xFF ))  # LSB
    
    echo "Configurando: $packets paquetes por pulso"
    echo "Bytes (big-endian): $(printf '\\x%02x\\x%02x\\x%02x\\x%02x' $byte3 $byte2 $byte1 $byte0)"
    echo "Enviando a: $FPGA_IP:$FPGA_PORT"
    
    printf "PKT#\x$(printf '%02x' $byte3)\x$(printf '%02x' $byte2)\x$(printf '%02x' $byte1)\x$(printf '%02x' $byte0)" | \
    nc -u -w 1 $FPGA_IP $FPGA_PORT
    
    local mb_size=$((packets * 8192 / 1024 / 1024))
    local gb_size=$(echo "scale=2; $packets * 8192 / 1024 / 1024 / 1024" | bc)
    
    if [ "$packets" -eq "$max_uint32" ]; then
        echo "Configurado para MÁXIMO: $packets paquetes (~${gb_size} GB por pulso)"
    else
        echo "Configurado para $packets paquetes (~${mb_size} MB por pulso)"
    fi
}

# --------------------------------------------------
# FUNCIÓN: fpga_error_pkt_n
# Configura cada cuantos paquetes y en que posicion en el paquete estara el mensaje de error
# Uso: fpga_error_pkt_n <frecuencia_de_paquetes> <posicion_en_paquete>
# Ejemplo: fpga_error_pkt_n 819200 512
# --------------------------------------------------
function fpga_error_pkt_n {
    # CORRECCIÓN: $# -ne 2 (no 1 2)
    if [ $# -ne 2 ]; then
        echo "Uso: fpga_error_pkt_n <frecuencia_de_paquetes> <posicion_en_paquete>"
        echo "Ejemplo: fpga_error_pkt_n 819200 512"
        return 1
    fi
    
    local packets=$1
    local poss=$2
    local max_uint32=4294967295
    local max_pos=1024
    
    # Validar que frecuencia de paquete sea un número positivo dentro de 32 bits
    if ! [[ "$packets" =~ ^[0-9]+$ ]] || [ "$packets" -lt 1 ] || [ "$packets" -gt "$max_uint32" ]; then
        echo "Error: La frecuencia de paquetes debe estar entre 1 y $max_uint32"
        return 1
    fi

    # Validar que posicion en paquete sea un número positivo dentro del rango 0-1023
    if ! [[ "$poss" =~ ^[0-9]+$ ]] || [ "$poss" -gt "$max_pos" ]; then
        echo "Error: La posición debe estar entre 0 y $max_pos"
        return 1
    fi
    
    # Convertir número a 4 bytes en BIG-ENDIAN
    local byte3=$(( (packets >> 24) & 0xFF ))  # MSB
    local byte2=$(( (packets >> 16) & 0xFF ))
    local byte1=$(( (packets >> 8)  & 0xFF ))
    local byte0=$(( (packets >> 0)  & 0xFF ))  # LSB

    # Convertir posición a 2 bytes en BIG-ENDIAN
    local poss_byte1=$(( (poss >> 8)  & 0xFF ))  # MSB
    local poss_byte0=$(( (poss >> 0)  & 0xFF ))  # LSB
    
    echo "Configurando: error cada $packets paquetes"
    echo "Bytes frecuencia (big-endian): $(printf '\\x%02x\\x%02x\\x%02x\\x%02x' $byte3 $byte2 $byte1 $byte0)"
    echo "Enviando a: $FPGA_IP:$FPGA_PORT"
    
    # Enviar comando de frecuencia
    printf "ERR#\x$(printf '%02x' $byte3)\x$(printf '%02x' $byte2)\x$(printf '%02x' $byte1)\x$(printf '%02x' $byte0)" | \
    nc -u -w 1 $FPGA_IP $FPGA_PORT
    
    # Pequeña pausa entre comandos
    sleep 0.1
    
    echo "Configurando: error en posición $poss del paquete"
    echo "Bytes posición (big-endian): $(printf '\\x%02x\\x%02x' $poss_byte1 $poss_byte0)"
    echo "Enviando a: $FPGA_IP:$FPGA_PORT"
    
    # Enviar comando de posición
    printf "ERR_P#\x$(printf '%02x' $poss_byte1)\x$(printf '%02x' $poss_byte0)" | \
    nc -u -w 1 $FPGA_IP $FPGA_PORT
    
    echo "Configuración enviada: Error cada $packets paquetes en posición $poss"
}

# --------------------------------------------------
# FUNCIÓN: fpga_trigger  
# Envía pulso de trigger a la FPGA
# Uso: fpga_trigger
# --------------------------------------------------
function fpga_trigger {
    local message="TRIGGER_"
    echo "Enviando pulso: $message"
    echo -n "$message" | nc -u -w 1 $FPGA_IP $FPGA_PORT
    echo " Comando Pulso enviado"
}

# --------------------------------------------------
# FUNCIÓN: interface_set
# Configurar IP por defecto
# --------------------------------------------------
function interface_set {
    local interface="${1:-$NET_INTERFACE}"
    sudo ip addr add 192.168.1.100/24 dev $interface 2>/de>null
    echo "IP 192.168.1.100 configurada"
    sudo ip link set dev $interface mtu 9000
    echo "MTU cambiada a 9000"
}

# --------------------------------------------------
# FUNCIÓN: interface_up
# Activar interfaz de red
# --------------------------------------------------
function interface_up {
    local interface="${1:-$NET_INTERFACE}"
    echo "Activando interfaz: $interface"
    sudo ip link set $interface up
    sleep 2
    if ip link show $interface | grep -q "state UP"; then
        echo "Interfaz $interface ACTIVADA"
    else
        echo "Error activando interfaz"
    fi
}

# --------------------------------------------------
# FUNCIÓN: interface_down
# Desactivar interfaz de red
# --------------------------------------------------
function interface_down {
    local interface="${1:-$NET_INTERFACE}"
    echo "Desactivando interfaz: $interface"
    sudo ip link set $interface down
    sleep 2
    if ip link show $interface | grep -q "state DOWN"; then
        echo "Interfaz $interface DESACTIVADA"
    else
        echo "Error desactivando interfaz"
    fi
}

# --------------------------------------------------
# FUNCIÓN: interface_reset
# Reset completo de interfaz
# --------------------------------------------------
function interface_reset {
    local interface="${1:-$NET_INTERFACE}"
    echo "=== RESETEO INTERFAZ: $interface ==="
    interface_down $interface
    sleep 3
    interface_up $interface
    sleep 3
    echo "Interfaz $interface RESETEADA"
}
# --------------------------------------------------
# FUNCIÓN: network_status
# Estado de la interfaz de red
# --------------------------------------------------
function network_status {
    local interface="${1:-$NET_INTERFACE}"
    echo "=== ESTADO RED: $interface ==="
    ip addr show $interface
    echo ""
    echo "=== RUTAS ==="
    ip route | grep $interface
    echo ""
    echo "=== ESTADÍSTICAS ==="
    grep $interface /proc/net/dev
}

# --------------------------------------------------
# FUNCIÓN: fpga_compile
# Compilar código FPGA y carga bitstream
# --------------------------------------------------
function fpga_compile {

    local original_dir=$(pwd)
    local start_time=$(date +%s)

    cd "$FPGA_PROJECT_DIR"

    echo "======================================"
    echo " Iniciando compilación FPGA"
    echo " Fecha: $(date)"
    echo "======================================"

    # --- Sintesis ---
    echo "=== [1/4] Síntesis ==="
    vivado -mode batch -source run_synth.tcl -tclargs -jobs 16
    echo ""

    # --- Implementación ---
    echo "=== [2/4] Implementación ==="
    vivado -mode batch -source run_impl.tcl -tclargs -jobs 16
    echo ""

    # --- Generación de bitstream ---
    echo "=== [3/4] Bitstream ==="
    vivado -mode batch -source generate_bit.tcl -tclargs -jobs 16
    echo ""

    # --- Programación de FPGA ---
    echo "=== [4/4] Programando FPGA ==="
    vivado -mode batch -source program.tcl
    echo ""

    # --- Medir duración total ---
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))

    echo "======================================"
    echo "Bitstream cargado en FPGA"
    echo "Tiempo total: ${minutes} min ${seconds} s"
    echo "======================================"

    cd "$original_dir"

}

# --------------------------------------------------
# FUNCIÓN: fpga_load
# carga bitstream
# --------------------------------------------------
function fpga_load {

     local original_dir=$(pwd)

     cd "$FPGA_PROJECT_DIR"
    
     # --- Programación de FPGA ---
    echo "=== Programando FPGA ==="
    vivado -mode batch -source program.tcl
    echo ""

    cd "$original_dir"

}

# --------------------------------------------------
# FUNCIÓN AUXILIAR: get_signal_name
# Devuelve el nombre legible de la señal según su índice
# --------------------------------------------------
function get_signal_name {
    case $1 in
        0) echo "tx_udp_hdr_valid" ;;
        1) echo "tx_udp_hdr_ready" ;;
        2) echo "rx_udp_hdr_valid" ;;
        3) echo "rx_udp_hdr_ready" ;;
        4) echo "tx_udp_payload_axis_tvalid" ;;
        5) echo "tx_fifo_axis_tready" ;;
        6) echo "tx_udp_payload_axis_tlast" ;;
        7) echo "udp_tx_busy" ;;
        8) echo "udp_rx_busy" ;;
        9) echo "rx_loopb" ;;
       10) echo "signal_in[0]";;
       11) echo "signal_in[1]";;
       12) echo "signal_in[2]";;
       13) echo "signal_in[3]";;
       14) echo "rx_random";;
        *) echo "rx_trigger" ;;
    esac
}

# --------------------------------------------------
# FUNCIÓN: fpga_debug_signals
# Configura las señales de debug en los pines JA_FPGA[7:4]
# Uso: fpga_debug_signals <JA7> <JA6> <JA5> <JA4>
#      0: tx_udp_hdr_valid     5: tx_fifo_axis_tready
#      1: tx_udp_hdr_ready     6: tx_udp_payload_axis_tlast  
#      2: rx_udp_hdr_valid     7: udp_tx_busy
#      3: rx_udp_hdr_ready     8: udp_rx_busy
#      4: tx_udp_payload_axis_tvalid  9: rx_loopb
#      otros: rx_trigger
#
# Ejemplo: fpga_debug_signals 9 6 5 4  # Valores por defecto
# Ejemplo: fpga_debug_signals 7 8 0 2  # udp_tx_busy, udp_rx_busy, tx_udp_hdr_valid, rx_udp_hdr_valid
# --------------------------------------------------
function fpga_debug_signals {
    if [ $# -ne 4 ]; then
        echo "Uso: fpga_debug_signals <JA7> <JA6> <JA5> <JA4>"
        echo "Donde cada valor puede ser:"
        echo "  0: tx_udp_hdr_valid"
        echo "  1: tx_udp_hdr_ready" 
        echo "  2: rx_udp_hdr_valid"
        echo "  3: rx_udp_hdr_ready"
        echo "  4: tx_udp_payload_axis_tvalid"
        echo "  5: tx_fifo_axis_tready"
        echo "  6: tx_udp_payload_axis_tlast"
        echo "  7: udp_tx_busy"
        echo "  8: udp_rx_busy"
        echo "  9: rx_loopb"
        echo " 10: signal_in[0]"
        echo " 11: signal_in[1]"
        echo " 12: signal_in[2]"
        echo " 13: signal_in[3]"
        echo " 14: rx_random"
        echo "  otros: rx_trigger"
        echo ""
        echo "Ejemplo: fpga_debug_signals 9 6 5 4  # Valores por defecto"
        echo "Ejemplo: fpga_debug_signals 7 8 0 2  # Monitorizar busy flags y headers"
        return 1
    fi
    
    local ja7=$1
    local ja6=$2
    local ja5=$3
    local ja4=$4
    
    # Validar que los valores estén entre 0 y 15 (4 bits)
    for val in $ja7 $ja6 $ja5 $ja4; do
        if ! [[ "$val" =~ ^[0-9]+$ ]] || [ "$val" -lt 0 ] || [ "$val" -gt 15 ]; then
            echo "Error: Los valores deben estar entre 0 y 15"
            return 1
        fi
    done
    
    # Construir el valor de 16 bits: [ja7:12-15][ja6:8-11][ja5:4-7][ja4:0-3]
    local debug_value=$(( (ja7 << 12) | (ja6 << 8) | (ja5 << 4) | ja4 ))
    
    # Convertir a 2 bytes en little-endian para la FPGA
    local byte_low=$(( debug_value & 0xFF ))         # Bits [7:0]
    local byte_high=$(( (debug_value >> 8) & 0xFF )) # Bits [15:8]
    
    echo "--------------------------------------------------"
    echo "Configurando debug signals:"
    echo "  JA_FPGA[4]: $ja4 → $(get_signal_name $ja4)"
    echo "  JA_FPGA[5]: $ja5 → $(get_signal_name $ja5)"
    echo "  JA_FPGA[6]: $ja6 → $(get_signal_name $ja6)"
    echo "  JA_FPGA[7]: $ja7 → $(get_signal_name $ja7)"
    echo "--------------------------------------------------"
    echo "  Valor combinado: 0x$(printf '%04x' $debug_value)"
    echo "  Bytes enviados (little-endian): 0x$(printf '%02x' $byte_high) 0x$(printf '%02x' $byte_low)"
    echo "  Destino: ${FPGA_IP:-192.168.1.128}:${FPGA_PORT:-1234}"
    
    # Enviar comando DEBUG_ + bytes en little-endian
    printf "DEBUG_\x$(printf '%02x' $byte_high)\x$(printf '%02x' $byte_low)" | \
    nc -u -w 1 ${FPGA_IP:-192.168.1.128} ${FPGA_PORT:-1234}
    
    if [ $? -eq 0 ]; then
        echo " Configuración enviada exitosamente"
    else
        echo " Error al enviar configuración"
        return 1
    fi
}

# --------------------------------------------------
# FUNCIÓN: show_fpga_commands
# Mostrar todos los comandos disponibles
# --------------------------------------------------
function show_fpga_commands {
	echo "=== COMANDOS FPGA DISPONIBLES ==="
	echo "fpga_init             - Iniciar envio de datos"
	echo "fpga_fini             - Fin de envio de datos"
	echo "interface_up          - Activar interfaz"
	echo "interface_down        - Desactivar interfaz"
	echo "interface_reset       - Resetear interfaz"
	echo "network_status        - Estado de red"
	echo "show_fpga_commands    - Esta ayuda"
	echo "interface_set         - Configura IP"
	echo "fpga_pkt_n [n]        - Conf numero de paquetes"
	echo "fpga_trigger          - Envía comando de trigger"
    echo "fpga_compile          - Compila y carga bitstream"
    echo "fpga_load             - Carga bitstream"
    echo "fpga_error_pkt_n      - Configura palabra de error"
    echo "fpga_loopback [e/d]   - Control loopback"
    echo "fpga_debug_signals [s]- Configura las señales de debug"
    echo "fpga_random           - Control Random"
    echo "================================="
}   
